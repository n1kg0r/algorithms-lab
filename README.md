# algorithms-lab

# Volume 1 — Data Structures (from scratch)

1. Arrays & Sequences

  - dynamic arrays

  - amortized analysis

- resize strategies

- cache friendliness (intuition)

2. Linked Structures

- singly / doubly linked lists

- tradeoffs vs arrays

- reversing, merging

3. Stacks & Queues

- stack via array

- queue via circular buffer

- deque

- applications (parsing, BFS)

4. Hash Tables

- hash functions

- collisions

- probing vs chaining

- complexity intuition

5. Trees & Heaps

- binary trees

- BST

- heaps

- priority queues

- tree vs heap mental models

# Volume 2 — Core Algorithms

6. Sorting

- quadratic sorts (why they exist)

- merge sort

- quicksort

- heap sort

- stability & in-place tradeoffs

7. Divide & Conquer

- binary search

- recursion trees

- quickselect

- master theorem (visual)

8. Dynamic Programming

- memoization vs tabulation

- Fibonacci (state explosion)

- knapsack

- LIS

- edit distance

- DP on DAGs

9. Greedy Algorithms

- interval scheduling

- activity selection

- Huffman coding

- when greedy fails

# Volume 3 — Graphs

10. Graph Representations

- adjacency list vs matrix

- memory & runtime tradeoffs

11. Traversal

- BFS

- DFS

- connected components

- recursion vs stack

12. Shortest Paths

- Dijkstra

- Bellman–Ford

- Floyd–Warshall

- negative cycles intuition

13. Classic Graph Problems

- cycle detection

- bipartite check

- topological sort

- DAG DP

# Volume 4 — Algorithms as Math 

14. Fourier Intuition

- rotating vectors

- projection

- frequency domain

- signal reconstruction

15. Discrete Fourier Transform

- DFT from definition

- convolution

- circular convolution

16. Fast Fourier Transform

- divide & conquer

- Cooley–Tukey

- bit reversal

- complexity leap (N² → N log N)

17. Applications

- signal filtering

- smoothing

- audio intuition (offline)

